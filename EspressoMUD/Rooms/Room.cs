using EspressoMUD.Geometry;
using KejUtils;
using KejUtils.SharedLocks;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using static EspressoMUD.TickManager;

namespace EspressoMUD
{
    public abstract class Room : IRoomContainer, ISaveable, ILockable
    {
        public Room RoomObject { get { return this; } }

        //TODO now:
        //  RoomItem or something similar for room's shape/features (floor, wall, ceiling, etc.)
        //      future would probably be a list of sub items or something like that. Don't have composite items right now though.
        //      for right now probably just a list of items?
        //      need to figure out a good design for floors or other surfaces that are shared between rooms
        //          Can multiple rooms just have the same item? How about, the item is managed by the outside room, but the inside room(s) know about them and reference them as the room limits?
        //  List of obstacles for pathing?
        //  World position?
        //      Simple rectangular coordinate and rotation based on some origin of the world.
        //          Is rotation actually needed? For an item room probably yes. For rooms generated by obstacle context... ? It still definitely makes sense to affect the surfaces. It would be complicated to decide if it's appropriate to affect the space in between too. Might be best to just affect all rooms the same.
        //          How to handle other things? E.g. portal to a completely undetached dimension? List of exits required to reach it?
        //              Maybe more something like List of ExitItems. Items must be in one specific location, so that item must be in the same dimension. Going through the exit associated with that item will put you in another location, possibly another dimension. Then the next ExitItem in the list must be accessible from there.
        //              Problem of transitioning from a position-based world to a simplified room with no positions (e.g. backpack) to a position-based room again (e.g. tiny house with more rooms).
        //                  This seems more like a general problem of simplified rooms actually. Needs a special measurement to handle ambiguous distances.
        //      Let's make this a lazy property. If a default value, recalulate from parent. Topmost parent is always valid and 0,0,0
        //          What should be the default value to check against? 0,0,0 isn't that great, though it's not really that bad either. A simple boolean might actually be best. Let's go with that for now.

        [SaveSubobject("Position")]
        private PositionOfRoom position;
        public PositionOfRoom Position
        {
            get { return position; }
            set { position = value; position.Parent = this; }
        }

        public Geometry.WorldRelativePosition WorldPosition;

        public void SetWorldPosition()
        {
            if (position == null || position.ForRoom == null)
            {
                WorldPosition = new Geometry.WorldRelativePosition(); //Set to default. This is the outermost room of the world.
                return;
            }

            Room container = position.ForRoom;

        }


        [SaveField("Items")]
        private ListItems contents = new ListItems();

        /// <summary>
        /// Add an item 
        /// </summary>
        /// <param name="item"></param>
        protected virtual void AddItem(Item item)
        {
            contents.Add(item);
            this.Save();
        }
        protected virtual bool RemoveItem(Item item)
        {
            if (contents.Remove(item))
            {
                this.Save();
                return true;
            }
            return false;
        }

        /// <summary>
        /// Handle items that are anchored in another room, but are partially in this room also.
        /// </summary>
        /// <param name="item">Item to add</param>
        /// <returns>True if the item was added. Some rooms may not support overlapping items.</returns>
        protected virtual bool AddOverlappingItem (Item item)
        {
            return false;
        }
        /// <summary>
        /// Handle items that are anchored in another room, but are partially in this room also.
        /// </summary>
        /// <param name="item"></param>
        /// <returns>True if the item was found and removed.</returns>
        protected virtual bool RemoveOverlappingItem (Item item)
        {
            return false;
        }

        public Item[] GetItems()
        {
            return contents.GetAll();
        }
        public virtual List<Item> FindListeningItems(RoomEvent forEvent)
        {
            //Handles finding items that are observing or interacting with an event.

            //TODO: Decide what ways this can be detected and calculate where things that can detect it may be.
            //For right now just getting everything in the same room.
            //Also TODO: If listeners are from another room, make sure to get that room lock? Or maybe that's the caller's responsibility?

            //Also TODO: Properly implement a find-all-items function. This won't find items in items.
            List<Item> foundItems = new List<Item>();
            foundItems.AddRange(contents.GetAll());
            return foundItems;
        }

        public virtual List<Item> FindNearbyInterestingItems(InterestingCheck interestCheck, WorldRelativeOrientation orientation, Hitbox range)
        {
            //Handles finding items that an event is observing or interacting with.

            if (range != null)
            {
                //TODO: Use Hitbox to spread to other rooms. Probably something like
                //foreach exit, if range.inRange(source, exit) && forEvent.spread(exit), exit.otherRoom.stuff(...)
                //Also TODO: Probably have alternatives for range that allow the room to account for visability or audibility


            }

            List<Item> foundItems = new List<Item>();
            for(int stop = contents.Count, i = 0; i < stop; i++)
            {
                Item nextItem = contents.Get(i);
                if (range != null && !range.InRange(orientation, nextItem.Size, nextItem.Position.WorldOrientation()))
                    continue;
                if (interestCheck(nextItem))
                    foundItems.Add(nextItem);
            }
            return foundItems;

        }

        /// <summary>
        /// List of ways things can go from this room to another room.
        /// </summary>
        [SaveField("Exits")]
        private ListRoomLinks exits = new ListRoomLinks();

        public RoomLink[] GetExits()
        {
            //TODO: Portal-like items and subrooms need to be included here eventually.
            return exits.GetAll();
        }

        protected virtual void AddExit(RoomLink exit)
        {
            exits.Add(exit);
            this.Save();
        }
        protected virtual bool RemoveExit(RoomLink exit)
        {
            if (exits.Remove(exit))
            {
                this.Save();
                return true;
            }
            return false;
        }

        #region Tick Management
        //Rooms are the resources that are locked on, so it also makes the most sense for Rooms to 'manage' the events that
        //want to happen in the future.
        private CircularList<BaseTask> tasks = new CircularList<BaseTask>();
        private bool runningTask = false;
        private BaseTask tickManagerRequest;
        public BaseTask QueueEvent(DateTime time, RoomEvent futureEvent)
        {
            RoomEventTask newTask = new RoomEventTask(futureEvent, this, time);
            AddTask(newTask);
            return newTask;
        }

        private void AddTask(BaseTask task)
        {
            lock (tasks)
            {
                int index = tasks.BinarySearch(task);
                if (index < 0) index = ~index;
                tasks.Insert(index, task);
                if (!runningTask && index == 0)
                {
                    if (tickManagerRequest != null)
                    {
                        bool wasCanceled;
                        if (tickManagerRequest.Cancel(out wasCanceled))
                        {
                            if (wasCanceled)
                            {
                                //need to submit a new task
                                WaitToNextTask(task);
                            }
                            else
                            {
                                //another thread canceled it already? This seems invalid. TODO: Log an error probably
                            }
                        }
                        //else don't need to do anything, another thread will get to it. Semi-race condition where the other thread
                        //is probably waiting on this lock.
                    }
                    else
                    {
                        //need to submit a new task
                        WaitToNextTask(task);
                    }
                }
            }
        }

        private void RemoveTask(BaseRoomTask task)
        {
            int index = tasks.BinarySearchDuplicates(task);
            if (index == -1) return; //Is this ever possible? I don't think so. If it's not in tasks there shouldn't be a problem though.
            tasks.RemoveAt(index);
            if (index == 0)
            {
                //TODO: reschedule TickManager task for this.
            }

        }

        /// <summary>
        /// Callback from the TickManager. Runs the next tasks in the queue until 
        /// </summary>
        private void RunNextTask()
        {
            BaseTask taskToRun = null;
            bool firstRun = true;
            while (true)
            {
                lock (tasks)
                {
                    tickManagerRequest = null; //This better be called because tickManagerRequest is running, so assume it's something and clear it here. It needs to be done during a lock though.
                    if (firstRun)
                    {
                        if (runningTask) //something has gone horribly wrong. TODO: Log an error.
                        {
                            return;
                        }
                    }
                    else
                    {
                        if (!runningTask) //something has gone horribly wrong. TODO: Log an error.
                        {
                            return;
                        }
                        runningTask = false;
                    }
                    while (true)
                    {
                        if (tasks.Count == 0)
                        {
                            return;
                        }
                        taskToRun = tasks[0];

                        if (taskToRun.IsCanceled())
                        {
                            tasks.RemoveAt(0);
                            continue;
                        }
                        if (taskToRun.scheduledTime > DateTime.UtcNow.AddMilliseconds(TickManager.NowLimit))
                        {
                            WaitToNextTask(taskToRun);
                            return;
                        }

                        taskToRun = tasks.RemoveAt(0);
                        break;
                    }
                    runningTask = true;
                }

                firstRun = false;
                taskToRun.Start();
            }
        }

        /// <summary>
        /// Should only be called while the caller is in lock(tasks). Queues 
        /// </summary>
        private void WaitToNextTask(BaseTask nextTask = null)
        {
            if (nextTask == null)
            {
                if (tasks.Count == 0)
                {
                    tickManagerRequest = null;
                    return;
                }
                nextTask = tasks[0];
            }
            tickManagerRequest = TickManager.Add(RunNextTask, nextTask.scheduledTime);
        }


        private abstract class BaseRoomTask : BaseTask
        {
            public Room owningRoom;

            public BaseRoomTask(Room owningRoom, DateTime scheduledTime) : base(scheduledTime)
            {
                this.owningRoom = owningRoom;
            }

            public override bool Cancel(out bool alreadyCanceled)
            {
                lock (owningRoom.tasks)
                {
                    bool canceled = base.Cancel(out alreadyCanceled);
                    if (canceled && !alreadyCanceled)
                    {
                        owningRoom.RemoveTask(this);
                    }
                    return canceled;
                }
            }
        }


        private class RoomEventTask : BaseRoomTask
        {
            public RoomEvent futureEvent;

            public RoomEventTask(RoomEvent futureEvent, Room owningRoom, DateTime scheduledTime) : base(owningRoom, scheduledTime)
            {
                this.futureEvent = futureEvent;
                this.owningRoom = owningRoom;
            }

            protected override void PerformTask()
            {
                futureEvent.FullRunEvent();
            }
        }

        #endregion

        //ISaveable template
        public SaveValues SaveValues { get; set; }

        //ILockable template
        public object LockMutex { get { return this; } }
        public LockableLockGroup CurrentLock { get; set; }

        [SaveID("ID")]
        protected int RoomID = -1; //Only supports IRoom ObjectType, so assume IRoom
        public int GetSaveID() { return RoomID; }
        public void SetSaveID(int id) { RoomID = id; }
    }


    public static partial class Extensions
    {
        public static Room GetRoom(MOB fromMob)
        {
            return fromMob.Body?.Position?.ForRoom;
        }
    }

}
